
\status{This chapter is currently WIP}

Early in the project
we tested two manually parallelised programs:
a raytracer and a mandelbrot image generator.
Both of them have a single significant loop
whose iterations are independent of one another.
We expect that automatic parallelisation would parallelise this loop
as it is the best place to introduce parallelism.
When we parallelised this loop manually we did
we did not get the speedups that we expected.
Therefore,
we chose to address the performance problems
before we worked on automatic parallelism.

In this chapter we investigate and correct these performance problems.
We start with the garbage collector in Section \ref{sec:gc};
we analyise the collector's effects on performance and tune its parameters
to improve performance.
In Section \ref{sec:original_scheduling} we describe how the existing runtime
system schedules sparks.
The section provides background material for Section
\ref{sec:d_scheduling_performance}
which benchmarks the runtime system and describes a significant problem with
spark scheduling.
We address those problems by introducing work stealing in Section
\ref{sec:work_stealing}.
This section is separated into two sub-sections
which describe the initial and revised versions of the work stealing
implementation.
Section \ref{sec:work_stealing} also includes benchmarks that show
how work stealing fixes the spark scheduling problem.
We made a number of improvements to the way that Mercury engines are created.
This includes thread pinning and support for SMT systems;
we describe these improvements in Section \ref{sec:thread_pinning}.
Finally, Section \ref{sec:idle_loop} describes our changes to how engines
idle,
and how and when they wake up to execute parallel work.

\section{Garbage collection tweaks}
\label{sec:gc}

\input{rts_gc}


\section{Original spark scheduling algorithm}
\label{sec:original_scheduling}

\status{This section is ready for review.}

\plan{Introduction}
We introduced parallelism in Mercury in Sections \ref{sec:backgnd_merpar} and
\ref{sec:backgnd_deppar};
we described how the runtime system in generic terms.
In this section we will explain how sparks were originally managed,
prior to 2009, when I begun my PhD candidature.
This will provide the background for the changes we have made to the
runtime since.

\plan{Global spark queue and Contention wrt global queue}
Mercury has a global spark queue.
The runtime easily schedules a spark by placing it on the end of the
global queue.
An idle engine runs a spark by taking it from the beginning of the queue.
The global spark queue must be protected by a lock;
this prevents concurrent access from corrupting the queue.
The global spark queue and its lock can easily become a bottleneck when many
engines content for access to the global queue.

\plan{Local spark stack --- relieves contention on global queue}
\citet{wang-hons} anticipated this problem and created context local spark
stacks to avoid contention on the global queue.
Furthermore, the local spark stacks do not require locking.
When a parallel conjunction spawns off a spark; it places the spark either
at the end of the global spark queue or at the top of its local spark stack.
\plan{Spark scheduling decision.}
The runtime system appends the spark to the end of the global queue if:
an engine is idle, and
the number of contexts in use plus the number of sparks on the global queue
does not exceed the maximum number of contexts permitted.
Otherwise,
the runtime system pushes the spark onto the top of the context's local
spark stack.
% Note, if I ever change citations I need to fix 'Wang' here.
% XXX The next line can be searched for to find citations.
% \citet
Wang's scheduling decision has two aims:
First, to reduce the contention on the global queue,
especially in the common case that there is enough parallel work.
This also reduces the amount of locking.
The second aim is to reduce the amount of memory allocated
as contexts' stacks by reducing the number of contexts allocated.
Globally scheduled sparks may be converted into contexts,
so they are also included in this limit.
Note that sparks placed on the global queue are executed in a
first-in-first-out manner;
sparks placed on a context's local stack are executed in a
last-in-first-out manner.

\begin{figure}
\begin{tabular}{rl}
 1 & \code{~~MR\_SyncTerm ST;} \\
 2 & \code{~~MR\_init\_syncterm(\&ST, 2);} \\
 3 & \code{~~spawn\_off(\&ST, Spawn\_Label\_1);} \\
 4 & \code{~~}$G_1$ \\
 5 & \code{~~MR\_join\_and\_continue(\&ST, Cont\_Label);} \\
 6 & \code{Spawn\_Label:} \\
 7 & \code{~~}$G_2$ \\
 8 & \code{~~MR\_join\_and\_continue(\&ST, Cont\_Label);} \\
 9 & \code{Cont\_Label:} \\
\end{tabular}
\caption{Parallel conjunction implementation}
\label{fig:par_conj_impl_only}
\end{figure}

\begin{algorithm}
\begin{algorithmic}
\Procedure{MR\_join\_and\_continue}{$ST, ContLabel$}
  \State acquire\_lock($ST.lock$)
  \State $ST.num\_outstanding \gets ST.num\_outstanding - 1$
  \If{$ST.num\_outstanding = 0$}
    \If{$ST.orig\_context = this\_context$}
      \State release\_lock($ST.lock$)
      \Goto{$ContLabel$}
    \Else
      \State $ST.orig\_context.resume\_label \gets ContLabel$
      \State schedule($ST.orig\_context$, $ContLabel$)
      \State release\_lock($ST.lock$)
      \Goto{MR\_get\_global\_work}
    \EndIf
  \Else
    \State $spark \gets$ pop\_spark
    \If{$spark$}
      \If{$spark.ST.stack\_ptr = MR\_parent\_sp$}
%        \Comment{This spark belongs to the same parallel conjunction.
%        It can be executed immediatly.}
        \State release\_lock($ST.lock$)
        \Goto{$spark.code\_label$}
      \EndIf
      \State push\_spark($spark$)
    \EndIf
    \If{$ST.orig\_context = this\_context$}
       \State suspend($this\_context$)
       \State $this\_context \gets$ NULL
    \EndIf
    \State release\_lock($ST.lock$)
    \Goto{MR\_get\_global\_work}
  \EndIf
\EndProcedure
\end{algorithmic}
\caption{MR\_join\_and\_continue}
\label{alg:join_and_continue_peterw}
\end{algorithm}

\plan{barrier code, this is used to explain the right recursion problem.}
In Section \ref{sec:backgnd_merpar} we described how parallel
conjunctions are compiled
(Figure \ref{fig:par_conj} shows an example).
Consider the compiled parallel conjunction in Figure
\ref{fig:par_conj_impl_only}.
The context that executes the parallel conjunction,
lets call it $C_{Orig}$,
begins by:
setting up the sync term,
spawning off $G_2$,
and executing $G_1$ (lines 1--4).
Then it executes the barrier code
\joinandcontinue, which is shown in
Algorithm \ref{alg:join_and_continue_peterw}.
The algorithm includes an optimisation not shown here:
if the parallel conjunction has been executed by only one context,
then a version of the algorithm that does not use locking is used.
This is not shown as it is equivalent and not relevant to
our discussion:
we mention it only for completeness.
Depending on how full the global run queue is,
and how parallel tasks are interleaved,
there are three important scenarios:

\begin{description}

    \item[Scenario one:]~

    The spark for $G_2$ was placed on $C_{Orig}$'s local spark stack.
    When $C_{Orig}$ reaches the \joinandcontinue barrier on line 5,
    there will be an outstanding conjunct ($G_2$) and so
    $ST.num\_outstanding \neq 0$.
    the else branch of the if-then-else will be executed,
    whereby the spark for $G_2$ will be popped off the top of the spark
    stack.
    Only the spark for $G_2$ can be on the stack:
    it was put on the stack before $G_1$ was called and $G_1$ cannot
    leave any sparks on the stack as its own \joinandcontinue barrier
    would have executed them.

    The check that the sparks stack pointer is equal to the current
    parent stack pointer will succeed,\footnote{
        The code generator will ensure that $MR\_parent\_sp$ is set
        before the parallel conjunction is executed,
        and that it is restored after.}
    and the context will execute the spark.

    After executing $G_2$,
    $C_{Orig}$ will execute the second call to the barrier code,
    the one on line 8.
    This time $ST.num\_outstanding = 0$,
    and the then branch of the if-then-else will be executed.
    Within this branch,
    execution will enter the then branch of the nested if-then-else
    because
    the current context is the original context.
    The code in this branch will jump to the continuation label on line
    9.
    This parallel conjunction has executed sequentially.

    \item[Scenario two:]~

    The spark for $G_2$ was placed on the global spark queue,
    where some other context, $C_{Other}$, picked it up and executed it
    in parallel.
    In this scenario, as distinct from scenario three,
    $C_{Other}$ reaches the barrier on line 8 \emph{before}
    $C_{Orig}$ reaches the barrier on line 5.
    Even if they both seem to reach the barrier at the same time.
    Their barrier operations are performed in sequence because of the
    lock protecting the barrier code.

    $C_{Other}$ executes \joinandcontinue (line 8).
    It will find that $ST.num\_outstanding \neq 0$,
    and will execute the else branch of the if-then-else.
    It will attempt to pop a spark of the stack,
    as a spark on the stack might representing the outstanding
    conjunction:
    it cannot tell that the outstanding conjunction is $G_1$ and not some
    hypothetical $G_3$.
    There will be no spark on the stack since $G_{Other}$ took this
    spark from the global queue, and therefore it is an empty context,
    and, as before, it is impossible for $G_2$ to return and leave a
    spark on $C_{Other}$'s stack.
    Therefore, execution will continue to the second if-then-else in
    this branch which will also fail since this context ($C_{Other}$)
    is not the original context ($C_{Orig}$).
    The look will be released and the barrier will exit,
    The current mercury engine and context will execute \getglobalwork.

    When $C_{Orig}$ executes its call to \joinandcontinue on line 5,
    it will find that $ST.num\_outstanding = 0$ and enter the then
    branch of the if-then-else.
    It will then enter the then branch of the nested if-then-else
    because it is the original context.
    This code jumps to the continuation label on line 9.
    The conjunction has executed in parallel.

    \item[Scenario three:]~

    As in scenario two,
    the spark for $G_2$ was placed on the global spark queue,
    where some other context, $C_{Other}$, picked it up and executed it
    in parallel.
    However,
    in this scenario
    $C_{Other}$ reaches the barrier on line 8 \emph{after}
    $C_{Orig}$ reaches the barrier on line 5.

    When $C_{Orig}$ executes \joinandcontinue on line 5,
    it will find that $ST.num\_outstanding \neq 0$.
    Execution will enter the then branch of the if-then-else.
    $C_{Orig}$ will try to pop a spark of its local spark stack,
    however the spark for $G_2$ will not be on the spark stack.
    $C_{Orig}$ might find a spark for a parent context's goal on the
    stack,
    if so, its stack pointer will not match the current parent stack
    pointer, and it will put the spark back on the stack.
    The second if-then-else's then branch will be entered, since this
    context is the original context.
    This branch will suspend $C_{Orig}$
    (copying context specific data from the engine into the context),
    and then set the engine's context pointer to NULL.
    before jumping to the \getglobalwork code.

    When $C_{Other}$ reaches the barrier on line 8,
    it will find that $ST.num\_outstanding = 0$,
    and will execute the then branch of the if-then-else.
    Within this branch it will test to see if it is the original
    context,
    the test will fail and the else branch of the nested if-then-else
    will be executed.
    At this point we know that $C_{Orig}$ must be suspended because
    there where no outstanding conjuncts and the current context is not
    the original context;
    this can only happen if $C_{Orig}$ is suspended.
    The code wakes $C_{Orig}$ up by
    setting its code pointer to the continuation label,
    placing it on the global run queue,
    and then jumps to \getglobalwork.

    When $C_{Orig}$ resumes execution it executes the code on line 9,
    which is the continuation label.

\end{description}

\begin{algorithm}[htb]
\begin{algorithmic}
\Procedure{MR\_get\_global\_work}{}
  \State acquire\_lock($MR\_runqueue\_lock$)
  \Loop
    \If{$MR\_exit\_now$}
      \State release\_lock($MR\_runqueue\_lock$)
      \State MR\_destroy\_thread()
    \EndIf
    \State $ctxt \gets$ MR\_get\_runnable\_context()
    \If{$ctxt$}
      \State release\_lock($MR\_runqueue\_lock$)
      \If{$current\_context$}
        \State MR\_release\_context($current\_context$)
      \EndIf
      \State MR\_load\_context($ctxt$)
      \Goto $ctxt.resume$
    \EndIf
    \State $spark \gets$ MR\_dequeue\_spark($MR\_global\_spark\_queue$)
    \If{$spark$}
      \State release\_lock($MR\_runqueue\_lock$)
      \If{$\neg current\_context$}
        \State $ctxt \gets$ MR\_get\_free\_context()
        \If{$\neg ctxt$}
          \State $ctxt \gets$ MR\_create\_context()
        \EndIf
        \State MR\_load\_context($ctxt$)
      \EndIf
      \State $MR\_parent\_sp \gets spark.parent\_sp$
      \State $ctxt.thread\_local\_mutables \gets
        spark.thread\_local\_mutables$
      \Goto $spark.resume$
    \EndIf
    \State wait($MR\_runqueue\_cond, MR\_runqueue\_lock$)
  \EndLoop
\EndProcedure
\end{algorithmic}
\caption{\getglobalwork}
\label{alg:MR_get_global_work}
\end{algorithm}

\plan{Explain how work begins executing, for completeness.}
When an engine cannot get any local work it must search for global work.
Newly created engines, except for the first, also search for global work.
This is done by calling \getglobalwork.
\getglobalwork is shown in Algorithm \ref{alg:MR_get_global_work}.
Only one of the idle engines can execute \getglobalwork at a time.
This protects the context run queue and the global context queue from
concurrent access using the run queue's lock.
After acquiring the lock,
engines execute a loop.
An engine exits the loop only when it finds some work to do or the
program is exiting.
Each iteration first checks if the runtime system is being shut down,
if so,
then this thread releases the lock,
and then destroys itself.
If the system is not being shut down,
the engine will search for a runnable context.
If it finds a context it releases the run queue lock, loads the context
and jumps to the resume point for the context.
If the engine already has a context,
that context is guaranteed to be unused;
therefore, it is released to the context free list.
If no context was found the engine attempts to take a spark from the global
spark queue.
If it finds a spark then it will need a context to execute the spark.
It will try to get a context from the free list, if there is none it will
create a new context.
Once it has a context,
it loads it.
This copies the context's copies of registers into the engine such as the
stack pointer.
It loads the spark by initialising the engine's parent stack pointer
register and the spark's thread local mutables
(which are set by the context that created the spark)
into the context.
If the engine does not find any work,
it will wait using a condition variable and the run queue lock.
The pthreads wait function is able to unlock the lock and wait on the
condition atomically, preventing race conditions.
The condition variable is used to wake up the engine if either a spark is
placed on the global spark queue or a context is placed on the context run
queue.
When the engine wakes,
it will re-execute the infinite loop.

%An engine looks for global work first by checking the global context run queue.
%If it finds a runnable context and is still holding a context from a
%previous execution, it saves the old context onto the free context list.
%If there are no runnable contexts,
%it will take a spark from the global spark queue,
%and either use its current context to execute the spark,
%or allocate a new context (from the free context list if possible).
%If it is unsuccessful at finding work,
%it will go to sleep using a pthread condition variable and the global run
%queue's lock.
%This condition is used to wake engines when either contexts are added to the
%run queue,
%or sparks are added to the spark run queue.

\section{Original spark scheduling performance}
\label{sec:oritinal_scheduling_performance}

\status{Checking plan for this section.}

\begin{figure}
\begin{center}
\subfigure[Right recursive]{%
\label{fig:map_right_recursive}
\begin{tabular}{l}
\code{map(\_, [], []).} \\
\code{map(P, [X $|$ Xs], [Y $|$ Ys]) :-} \\
\code{~~~~P(X, Y) \&} \\
\code{~~~~map(P, Xs, Ys).} \\
\end{tabular}}
\subfigure[Left recursive]{%
\label{fig:map_left_recursive}
\begin{tabular}{l}
\code{map(\_, [], []).} \\
\code{map(P, [X $|$ Xs], [Y $|$ Ys]) :-} \\
\code{~~~~map(P, Xs, Ys) \&} \\
\code{~~~~P(X, Y).} \\
\end{tabular}}%
\end{center}
\caption{Right and left recursive map/3}
\label{fig:map_right_and_left_recursive}
\end{figure}

Section \ref{sec:gc} we ran our benchmarks with a recent version of the
runtime system.
In the rest of this chapter we describe many of the improvements to the
runtime system that improved parallel performance.

\plan{Introduce right recursion.}
Figure \ref{fig:map_right_and_left_recursive} shows two alternative, parallel
implementations of \code{map/3}.
While their declarative semantics are identical,
their operational semantics are very different.
In Section \ref{sec:backgnd_merpar} we explained that parallel conjunctions
are implemented by spawning off the second and later conjuncts and executing
the first conjunct directly.
In the right recursive case (Figure \ref{fig:map_right_recursive}),
the recursive call is spawned off as a spark,
and that in the left recursive case (Figure \ref{fig:map_left_recursive}),
the recursive call is executed directly, and the loops \emph{body} is
spawned off.
Programmers are taught about tail recursion,
and therefore they write right recursive code wherever possible.

\begin{table}
\begin{center}
\begin{tabular}{r|rr|rrrr}
\multicolumn{1}{c|}{Max no.} &
\multicolumn{2}{c|}{Sequmential} &
\multicolumn{4}{c}{Parallel w/ $N$ Engines} \\
\Cbr{of contexts} & \C{not TS} & \Cbr{TS} & \C{1}& \C{2}& \C{3}& \C{4}\\
\hline
4        & 23.2 (0.93) & 21.5 (1.00)
         & 21.5 (1.00) & 21.5 (1.00) & 21.5 (1.00) & 21.5 (1.00) \\
64   &-&-& 21.5 (1.00) & 21.5 (1.00) & 21.5 (1.00) & 21.5 (1.00) \\
128  &-&-& 21.5 (1.00) & 19.8 (1.09) & 20.9 (1.03) & 21.2 (1.01) \\
256  &-&-& 21.5 (1.00) & 13.2 (1.63) & 15.5 (1.38) & 16.5 (1.30) \\
512  &-&-& 21.5 (1.00) & 11.9 (1.81) &  8.1 (2.66) &  6.1 (3.55) \\
1024 &-&-& 21.5 (1.00) & 11.8 (1.81) &  8.0 (2.67) &  6.1 (3.55) \\
2048 &-&-& 21.5 (1.00) & 11.9 (1.81) &  8.0 (2.67) &  6.0 (3.55) \\
\end{tabular}
\end{center}
\caption{Right recursion performance.}
\label{tab:right}
\end{table}

\plan{Show performance figures.}
Table \ref{tab:right} shows average elapsed time in seconds for the
mandelbrot\_lowalloc program from 20 test runs.
We use the mandelbrot\_lowalloc program from Section \ref{sec:gc}.
Using this program we can easily observe the
speedup due to parallelism in Mercury without the effects of the garbage
collector.
The loop that iterates over the rows in the image uses right recursion.
It is similar to \code{map/3}
in Figure \ref{fig:map_right_recursive}.
The left most column shows the maximum number of contexts permitted at
any time.
This is the limit that was described in the previous section.
Values are omitted in the range 3--31 as they are not interesting:
their results are the same as those for 2 contexts per engine.
The next two columns give the elapsed execution time for a sequential
version of the program,
in this version of the program no parallel conjunctions where used.
The first of these, labelled ``not TS'',
is compiled without thread safety;
the second, labelled ``TS'',
is compiled with thread safety, meaning that it allows multiple engines to be
used: requiring each thread to use a register to point to its engine
structure (Section \ref{sec:backgnd_merpar}).
The ``TS'' version also enables thread safety in the garbage collector.
The sequential versions of the programs do not use the context limit:
there is only one result for each sequential version of a program.
The following four columns give the elapsed execution times
using one to four Mercury engines.
The numbers in parentheses are the ratio between the result and the
sequential thread safe result.

\plan{Observations}
In general more parallelism is achieved when more contexts are used:
The mandelbrot program parallelises well with 512 contexts.
However,
if this limit is raised even higher,
to 1024 or 2048 contexts,
not much more parallelism is gained.
When only 256 contexts are used the four core version achieves a speedup
of 1.30,
compared to 3.55 for 512 or more contexts.
With fewer contexts, parallel speedups are limited.
Using independent parallelism there should be no need to suspend a context.
Therefore, the program should parallelise well enough when restricted to
a small (four to eight) number of contexts.
This suggests that there is a problem;
too many contexts are needed to execute this program.
We noticed the same pattern in other programs with right recursive
parallelism.
Interestingly,
with either 128 or 256 contexts,
adding more Mercury engines \emph{slows down} the program.
We will address this observation after explaining why right recursion
requires so many contexts.

\plan{Describe the context limit problem.}
%Right recursion uses a context for each iteration of the loop,
%and then suspends that context.
Parallel conjunctions are evaluated as described in Section
\ref{sec:backgnd_merpar}.
The second and later conjuncts are spawned off while the first conjunct is
executed by the current context.
The barrier at the end of the first conjunct will block the context if
the other conjuncts have not yet completed.
This is likely as the recursive call almost always requires more
computation than a single iteration.
The context must either execute a spark due to the same parallel
conjunction or be blocked.
It cannot continue execution after the parallel conjunction as the code
after the conjunction often depends on values produced by the other
conjuncts in the conjunction.
Every spark placed on the global queue is converted into a new context,
because no contexts have been released into the free list.
Each of these new contexts in turn enters the recursive call and
becomes blocked within the recursive instance of the same parallel
conjunction.
The number of contexts quickly exceeds the context limit preventing
parallel execution.
If the context limit is not exceeded then a right recursive loop will
consume a context for each level of recursion.

The mandelbrot program's parameters asked to to render an image with a
resolution of $600\times600$,
given that some sparks can be executed by the current context without
loosing much parallelism,
512 contexts is enough to effectively parallelise the program as shown in
the table.
It is important to note that each context consumes a significant amount
of memory, more than one stack frame.
Therefore,
this problem makes programs that look tail recursive
\emph{consume more memory than}
sequential programs that are not tail recursive.
This is the reason why there is a context limit,
to prevent a parallel Mercury program from consuming all the memory on a
system.
Later in the project we developed a solution to this problem which is
covered in Chapter \ref{chap:loop_control}.
In this chapter we investigate workarounds.

\plan{Extra engines require more contexts}
Above we noted that while using 128 or 256 contexts,
a program using three or four Mercury engines was slower than one using
two engines.
A possible reason is that:
the more Mercury engines there are the more often at least one engine is
idle.
This information is used when placing a spark on the global spark
queue (Section \ref{sec:original_scheduling}).
If there is no idle engine,
a spark is placed on the context's local queue regardless of the current
number of contexts.
This happens more often when there are fewer Mercury engines being used,
this means that the context limit will not be exceeded so quickly
and in the meantime,
more parallelism may be exploited.

\plan{Suggest that left recursion might fix this,
(This is what we thought at the time).}
Only right recursion behaves in this way.
A left recursive predicate (Figure \ref{fig:left_recursion} has its
recursive call on the left of the parallel conjunction.
The context executing the conjunction sparks off the body of the loop,
in the figure this is \code{P},
and executes the recursive call directly.
By the time the recursive call finishes,
the conjunct containing \code{P} should have also finished.
The context that created the parallel conjunction is less likely to be
blocked at the barrier,
and the context executing the spark is never blocked since it is not the
original context that executed the conjunction.

\begin{table}
\begin{center}
\begin{tabular}{r|rrrrrr}
\multicolumn{1}{c|}{Max no.} &
\multicolumn{2}{c|}{Sequmential} &
\multicolumn{4}{c}{Parallel w/ $N$ Engines} \\
\Cbr{of contexts} & \C{not TS} & \Cbr{TS}  & \C{1}& \C{2}& \C{3}& \C{4}\\
\hline
\hline
\multicolumn{7}{c}{Right recursion} \\
\hline
4        & 23.2 $\pm0.00$ & 21.5 $\pm0.04$
         & 21.5 $\pm0.02$ & 21.5 $\pm0.00$ & 21.5 $\pm0.01$ & 21.5 $\pm0.02$ \\
64   &-&-& 21.5 $\pm0.03$ & 21.5 $\pm0.01$ & 21.5 $\pm0.01$ & 21.5 $\pm0.02$ \\
128  &-&-& 21.5 $\pm0.02$ & 19.8 $\pm0.01$ & 20.9 $\pm0.03$ & 21.2 $\pm0.03$ \\
256  &-&-& 21.5 $\pm0.02$ & 13.2 $\pm0.05$ & 15.5 $\pm0.06$ & 16.5 $\pm0.07$ \\
512  &-&-& 21.5 $\pm0.02$ & 11.9 $\pm0.11$ &  8.1 $\pm0.09$ &  6.1 $\pm0.08$ \\
1024 &-&-& 21.5 $\pm0.03$ & 11.8 $\pm0.11$ &  8.0 $\pm0.06$ &  6.1 $\pm0.08$ \\
2048 &-&-& 21.5 $\pm0.03$ & 11.9 $\pm0.10$ &  8.0 $\pm0.08$ &  6.0 $\pm0.06$ \\
\hline
\hline
\multicolumn{7}{c}{Left recursion (Sparks included in context limit)} \\
\hline
4        & 23.2 $\pm0.01$ & 21.5 $\pm0.03$
         & 21.5 $\pm0.02$ & 21.5 $\pm0.04$ & 21.5 $\pm0.04$ & 21.5 $\pm0.02$ \\
64   &-&-& 21.5 $\pm0.02$ & 21.5 $\pm0.02$ & 21.4 $\pm0.03$ & 21.5 $\pm0.03$ \\
128  &-&-& 21.5 $\pm0.04$ & 21.5 $\pm0.03$ & 21.5 $\pm0.03$ & 21.5 $\pm0.03$ \\
256  &-&-& 21.5 $\pm0.02$ & 18.3 $\pm0.75$ & 18.2 $\pm0.03$ & 19.6 $\pm1.37$ \\
512  &-&-& 21.5 $\pm0.02$ & 17.9 $\pm0.83$ & 15.5 $\pm1.29$ & 16.4 $\pm7.09$ \\
1024 &-&-& 21.5 $\pm0.03$ & 18.0 $\pm0.85$ & 14.7 $\pm2.18$ & 16.1 $\pm5.23$ \\
2048 &-&-& 21.5 $\pm0.02$ & 18.0 $\pm0.85$ & 15.4 $\pm2.15$ & 17.8 $\pm5.25$ \\
\hline
\hline
\multicolumn{7}{c}{Left recursion (Sparks excluded from context limit)} \\
\hline
N/A      & 23.3 $\pm0.01$ & 21.5 $\pm0.02$
         & 21.7 $\pm0.78$ & 17.9 $\pm0.60$ & 15.6 $\pm2.49$ & 14.2 $\pm6.94$ \\
\end{tabular}
\end{center}
\caption{
Right and Left recursion shown with standard deviation}
\label{tab:2009_left_nolimit}
\end{table}

\plan{Show performance figures for left recursion.}
Table \ref{tab:2009_left_nolimit} shows benchmark results using left
recursion.
The table is broken into three sections:
a copy of the right recursion data from Table \ref{tab:right},
which is presented again for comparison;
the left recursive data,
which we will discuss now;
and left recursive data with a modified context limit,
which we will discuss in a moment.
As above, the first column represents the maximum number of contexts
allowed.
The next two columns give the sequential execution time, without and
with thread safety.
And the remaining four columns give the results for the parallelised
program using one to four Mercury engines.
All results are the mean of 20 test runs,
printed next to each result is the sample standard deviation.

The left recursive figures are underwhelming, they are worse than right
recursion.
Furthermore,
the sample standard deviations in for left recursion results are much
higher.
In particular,
the more contexts and Mercury engines are used, the higher the
deviation.
This means that few observations can be made using this data,
however,
the results are still much slower than the right recursive results and
the large amount of variance in the results are observations that we can
make.

\plan{Explain the premature scheduling problem that affects left-recursive programs.}
The left recursion problem looks similar to the right recursive problem
since they are both affected by the context limit.
However, they are different.
To demonstrate the left recursion problem,
let us assume that there is a context limit of eight,
and there are two Mercury engines.
The first Mercury engine is executing the original context,
which enters the parallel conjunction and spawns off a spark adding it
to the global queue.
The context then executes the recursive call continues to spawn off
sparks.
As we described in Section \ref{sec:original_scheduling},
each spark on the global spark queue may be converted into a new
context,
and therefore, sparks on the global queue contribute towards the context
limit.
After eight recursions,
it is very likely that the context limit has been exceeded.
It may not have been.
The number of contexts and sparks will be reduced
when the second engine executes its second spark,
as it allocates a new context to execute the first spark and re-uses it
for the second.
If the second engine is quick enough,
the first engine may have been able to place 9 or 10 sparks on the
global queue before the limit was exceeded,
but this is unlikely.
The first Mercury engine is doing nothing more than following a
recursive call,
setting up a synchronisation term and
then scheduling a spark;
each iteration is very quick.
Meanwhile,
the second Mercury engine is executing the call to \code{P} in each
recursion;
which is much slower.
Therefore,
sparks are being created more quickly than they can be executed.
When using a low context limit most of these sparks are placed on
the original context's local stack,
and will be executed sequentially.

\plan{Left recursion w/out limit results}
The left recursive version of mandelbrot uses independent
parallelism and left recursion;
it never needs more than one context per Mercury engine.
Therefore, we are able to safely remove sparks from the context limit
since we know that any contexts allocated in order to evaluate sparks
can be re-used.
The final row group (of a single row) in Table
\ref{tab:2009_left_nolimit} shows results for the left recursive test
with a modified context limit.
As such, the context limit is no-longer relevant to the test,
so only one row of values is shown.
The standard deviation for this result is still very high,
nearly seven seconds for four Mercury engines,
so it cannot be easily compared with other results.
Nevertheless, this result is similar to those in the left recursive
group that have a sufficiently high context limit.
This supports the idea above, however the program still performs poorly,
and the variance is high.

\plan{Second problem, discuss the high variance}
The high variance in all the left recursive results is
indicative of a nondeterminism.
The cause is going to be something that either varies between execution
runs or does not always effect execution runs.
Parallel task scheduling is a potential cause.
When a spark is scheduled and placed on either the global queue or
context local stack.
the context limit is one of the two things used to make this scheduling
decision;
the other is, if there is no idle engine then the spark is always
placed on the local spark stack (Section \ref{sec:original_scheduling}).
At the time when the parallel conjunction in \code{map/3} is executed,
the other engines will initially be idle but will quickly become busy,
once they are busy the original context will not place sparks on the
global spark queue.
If the other engines are slow to respond to the first sparks placed
on the global queue,
then a larger number of sparks are placed on this queue and more
parallel work is available.
If they are quick to respond,
then more sparks will be placed on the original contexts local queue,
where they will be executed sequentially.

\plan{Reinforce that these results support the idea that scheduling decisions are made prematurely}
Both of the left recursive problems have the same cause.
The decision to execute a spark sequentially or in parallel is
made too early.
This decision is made when the spark is scheduled,
and placed either on the global spark queue or the context local spark
stack.
The data used to make the decision includes the number of contexts in
use,
the number of sparks on the global queue,
and if there is an idle engine.
These conditions will be different when the spark is scheduled compared
to when it may be executed,
and the conditions when it is scheduled are not a good indication of
the conditions when it may be executed.
We will refer to this problem as the \emph{premature spark scheduling problem}.
In the next section,
we solve this problem by delaying the decision to execute a spark in
parallel or in sequence.

%In the left recursive program scheduling is quite different.
%The parallel conjunction creates a spark for \code{P(X, Y)} and executes the
%recursive call directly.
%The spark is converted into a context,
%that context does not execute another parallel conjunction since it does not
%execute the recursive call.
%Therefore, it will not become blocked on the \joinandcontinue barrier in any
%nested parallel conjunction.
%It will execute the barrier after \code{P(X, Y)},
%this however does not block this context.
%The context is not the conjunction's original context and therefore once it
%reaches this barrier it is free,
%if it has any sparks on its local queue it may execute them,
%otherwise the engine executing it will look for global work,
%either another context or a spark from the global queue.
%If there is a spark on the global queue the engine will use this context to
%execute it since the context is otherwise unused.
%
%This led us to believe that the left recursion would be more efficient than
%right recursion,
%namely that since contexts are reused, the number of contexts wouldn't climb
%and prevent parallelism from being exploited.
%As Table \ref{tab:right_v_left} shows, we were wrong:
%the context limit is affecting performance.
%As discussed, a left-recursive loop spawns of calls to \code{P} as sparks
%and executes its recursive call directly.
%It will, very quickly,
%make many recursive calls, spawn off many sparks.
%The context limit includes sparks on the global queue since
%executing them can require the creation of new contexts,
%Furthermore, if they were not included and the runtime system refused to
%convert a spark on the global queue into a context the system could become
%deadlocked.
%In the left recursive case,
%the context limit will be reached very quickly,
%often before engines have begun taking sparks from the queue and executing
%them.
%Once the limit is reached sparks are placed on the contexts local queues
%where they cannot be executed in parallel.
%The smaller the context limit,
%the more quickly the limit is reached and the fewer contexts are placed on
%the global queue.
%Additionally,
%the loop placing sparks on its context's local stack will execute very
%quickly.
%
%We concluded that
%in the left recursive case
%the scheduling decision for each spark is made much earlier than the spark's
%execution.
%Specifically,
%when the decision to place the spark on the global queue or local stack is
%made,
%often the context limit has already been reached:
%\paul{Need to decide how I communicate who the actor is for scheduling
%decisions.}
%the context will place the spark on its local stack.
%Later, when a different engine becomes idle,
%it cannot access the spark since it is on another engine's context's spark
%stack.
%At this point it is apparent that the scheduling decision made when the
%spark was placed on the local stack was incorrect,
%as there is an idle engine ready to execute the spark,
%and because contexts are re-used (in left recursion) there is either a free
%context or we can easily create one.



\section{Work stealing implementation}
\label{sec:work_stealing}

\plan{Introduce work stealing}
Work stealing is a popular method for managing parallel work in a shared
memory multiprocessor system.
A number of language implementations use work stealing.
% XXX: There may be earlier papers by keller 1984 as cited by halstead.
\paul{XXX: I have skimed this paper, I must go back and read it
properly}
One of the earliest was Multilisp \citep{halstead:1985:multilisp};
In this paper,
Halstead discusses ``an unfair scheduling policy'',
in which each worker thread maintains a queue of tasks
and there is no global queue.
When a thread spawns off a task it places the task on its queue.
After completing a task, a thread looks for its next task first 
on its own queue, and if there is none
the thread attempts to steal a task from the other threads.
\paul{XXX: I have not read this paper yet.
It ranks highly in google scholar results and Peter used it so I suspect
that it is notable.}
Many more papers have been published about work stealing.
A notable example is
\citet{blumofe:1999:work-stealing},
which quantifiably proves that work stealing is more efficent than
\emph{work sharing}
(using a global pool of work).

\paul{XXX: Make sure these paragraphs flow once I read the papers above}
\plan{Refer to Peter Wang's conclusion of the early scheduling problem}
\citet{wangp-hons} also mentioned the premature spark scheduling problem
from the previous section.
However, he did not discuss it detail or
recognize that left recursion can create pathological behaviour.
Wang also proposes work stealing as a solution to the problem.
In a work stealing system a spark placed on a context local stack
is not comitted to running on that context;
it may be executed on a different context if it is stolen.
This delays the dicision of where to execute a spark until the moment
before it is executed.
Work stealing's other benifits can be summerised as follows:

\begin{itemize}

    \item
    A worker can schedule parallel work quickly,
    it is quicker to place work on a local queue rather than a global
    one:
    There is less contention on a local queue than a global one.

    \item
    A idle worker can take work from its own queue quickly.
    Again, there is less contention on a local queue.

    \item
    In ideal circumstances,
    an idle worker rarely needs to steal work from another's queue.
    Stealing work is more costly as it requires communication between
    processors.

\end{itemize}

\subsection{Initial work stealing implementation}

The initial work stealing implementation for Mercury was colaboration
between Peter Wang and myself, Wang contributed about 80\% of the work
and I contributed the remaining 20\%.
Wang's honors thesis \citep{wang-hons} describes his proposal on which
our implementation is heavily based.

\plan{Mercury's needs for a deque}
So far each context has used a stack to manage sparks.
The last item pushed onto the stack is the first to be popped off the
stack,
this \emph{last-in-first-out} order is important for Mercury's parallel
conjunctions.
The main reasion for this is that when parallelism is not used and
parallel conjunctions are nested,
either within the same predicate
or due to one or more predicate calls,
the last-in-first-out order ensures that the left most spark is executed
first.
This is important because it allows a future to \signal a variable in an
inner conjunct before \wait is executed on the future in the other
conjunct.
Therefore the data structure used for the deque must return sparks
for the local context in a last-in-first-out order.
This execution order does not affect multiple conjuncts in the same
parallel conjunction.
The second and later conjuncts are spawned off as a single spark
and the left most conjunct is executed directly.
The second reason to use a stack to manage context local sparks
is that the last-in-first-out order ensures that a poped spark's data
has a good chance of being hot in the processor's cache.

Sparks added to Mercury's global spark queue where 
returned in \emph{first-in-first-out} order.
This does not encourage a left to right execution order.
However \citet{wang_hons} proposes that this order may be better:

\begin{quote}
The global spark queue, however, is a queue because we assume that a
spark generated earlier will have greater amounts of work underneath it
than the latest generated spark, and hence is a better candidate for
parallel execution.
\end{quote}

\plan{Describe the data structure used to implement these stacks and its
properties.}
To preserve the last-in-first-out behaviour of context local spark
stacks,
and first-in-first-out behaviour of the global queue;
we chose to use double ended queues (deques) for context local spark
storage.
The deque implementation we chose 
is described by
\citet{Chase_2005_wsdeque}.
It supports nonblocking operation and is dynamically resizeable,
which are important for a work stealing deque.
The deque supports the following operations:

\begin{description}

    \item[\code{void push(deque *d, spark *s)}] The context that owns
        the deque can push items onto the top%
\footnote{
        Note when we refer to the top of the deque
        \citet{Chase_2005_wsdeque} referrs to the bottom and vice-versa.
        We prefer to use the terminology of pushing onto and popping off of
        top, as we would when discussing a stack.
        We clarify this with the hot and cold metaphor.}
    of the deque.
    This can be done without synchronisation.
    If necessary
    \push will grow the array that is used to implement the
    deque.

    \item[\code{bool pop(deque *d, spark **s)}] The deque's owner can pop items
    from the top of the queue.
    This can also be done without synchronisation,
    except for when the deque contains only one item.
    In this case an atomic compare and swap operation is used to
    determine if the thread lost a race to another thread attempting to
    steal a task from the deque (a \emph{theif}).
    When this happens the single item was stolen by the theif and the
    owner's call to \pop returns false,
    indicating that the deque was empty.

    \item[\code{result steal(deque *d, spark **s)}]
    A thread other than the deque's owner can steal
    items from the bottom of the deque.
    This always uses an atomic compare and swap operation as multiple
    theifs may call \steal on the same deque at the same time.
    \steal can return one of three different values:
    ``success'', ``failure'' and ``abort''.
    ``abort'' indicates that the theif lost a race with either the owner
    (\emph{victim}) or another theif.

\end{description}

All the atomic compare and swap operations here are wait free,
rather than looping \pop will return false and \steal will abort.
\push and \pop are very fast, this is good as a context uses its own
spark deque more often than calling \steal on another's.
\steal is slightly slower than either \push or \pop,
but is still quite fast.
This is good because a context will 
\push and \pop sparks onto and off of its local deque
more often than it will \steal a spark from another's deque.
This means that the top of the deque is used more often than the bottom.
Therefore, we refer to the top as the \emph{hot} end,
and to the bottom as the \emph{cold} end.
These terms are less confusing than the disagreement between the stack
like behaviour of a deque from its context's perspective,
and the terminology used by \citet{Chase_2005_wsdeque}. 

Mercury was already using Chase's deques for spark storage,
most likely because Wang had always planned to implement work stealing.
We did not need to replace the data structure used for a context local
spark storage,
but we will now refer to it as a deque rather than a stack.
We have removed the global spark queue,
as work stealing does not use one.
Concequently,
when a context creates a spark that spark is always placed on the
context's local spark queue.

\begin{algorithm}
\begin{algorithmic}
\Procedure{MR\_join\_and\_continue}{$ST, ContLabel$}
  \State $finished \gets$ atomic\_dec\_and\_is\_zero($ST.num\_outstanding$)
  \If{$finished$}
    \If{$ST.orig\_context = this\_context$}
      \Goto{$ContLabel$}
    \Else
      \While{$ST.orig\_context.resume\_label \neq ContLabel$}
        \State CPU\_relax
      \EndWhile
      \State schedule($ST.parent$, $ContLabel$)
      \Goto{MR\_get\_global\_work}
    \EndIf
  \Else
    \State $spark \gets$ pop\_spark
    \If{$spark$}
      \Goto{$spark.code\_label$}
    \Else
      \If{$ST.orig\_context = this\_context$}
         \State suspend($this\_context$)
         \State $this\_context.resume\_label \gets ContLabel$
         \State $this\_context \gets$ NULL
      \EndIf
      \Goto{MR\_get\_global\_work}
    \EndIf
  \EndIf
\EndProcedure
\end{algorithmic}
\caption{MR\_join\_and\_continue}
\label{alg:join_and_continue_ws1}
\end{algorithm}

\plan{Barrier code}

\begin{algorithm}
\begin{algorithmic}
\Procedure{MR\_get\_global\_work}{}
  \State acquire\_lock($MR\_runqueue\_lock$)
  \Loop
    \If{$MR\_exit\_now$}
      \State release\_lock($MR\_runqueue\_lock$)
      \State MR\_destroy\_thread()
    \EndIf
    \State $ctxt \gets$ MR\_get\_runnable\_context()
    \If{$ctxt$}
      \State release\_lock($MR\_runqueue\_lock$)
      \If{$current\_context$}
        \State MR\_release\_context($current\_context$)
      \EndIf
      \State MR\_load\_context($ctxt$)
      \Goto $ctxt.resume$
    \EndIf
    \If{$MR\_num\_outstanding\_contexts < MR\_max\_contexts$}
      \State $spark \gets$ MR\_try\_steal\_spark()
      \If{$spark$}
        \State release\_lock($MR\_runqueue\_lock$)
        \If{$\neg current\_context$}
          \State $ctxt \gets$ MR\_get\_free\_context()
          \If{$\neg ctxt$}
            \State $ctxt \gets$ MR\_create\_context()
          \EndIf
          \State MR\_load\_context($ctxt$)
        \EndIf
        \State $MR\_parent\_sp \gets spark.parent\_sp$
        \State $ctxt.thread\_local\_mutables \gets
          spark.thread\_local\_mutables$
        \Goto $spark.resume$
      \EndIf
    \EndIf
    \State wait($MR\_runqueue\_cond, MR\_runqueue\_lock$)
  \EndLoop
\EndProcedure
\end{algorithmic}
\caption{\getglobalwork}
\label{alg:MR_get_global_work}
\end{algorithm}

\plan{Other changes to the idle loop?}

\plan{Theif behaviour}
\plan{Accessing the array of deques}

\plan{Work stealing attempts}

\plan{Describe work stealing timeout.}

\plan{Work stealing fixes the premature scheduling decision problem}

\input{tab_work_stealing_initial}


\plan{Benchmark}

This subsection was joint work with Peter Wang.

\plan{Avoid the right-recursion problem by reordering independent conjunctions.}

\subsection{Revised work stealing implementation}

\plan{Describe problems with associating stacks with contexts}
The number of stacks varies,
Stealing uses a global lock to determine which stack to steal from.

\plan{Prove that even though there are N engines and M contexts and M may be
larger than N, that there will be at most N of the M contexts with work on
their queues}
Therefore:
Stealing is unnecessary complicated.
In pathological cases many attempts can be made without success,
a thief may give up even though there is parallelism.

\plan{We associate stacks with engines}
This removes the above problems how.

\plan{Show stealing algorithm there are any,}
Find out if I started tracking stealing per engine or not.

\plan{Show how this is safe.}
When a parallel conjunction's barrier is executed and a conjunct is
outstanding, if its spark is on this engine's stack it must be at the top of
the stack.
This invariant should be kept because the context can be re-used if
'compatible' work is found at the top of the spark stack.
This invariant is soft.

\plan{Benchmark}

\section{Thread pinning}
\label{sec:thread_pinning}
\status{Not written}

\plan{Explain why we want $P$ engines when there are $P$ processors}

\plan{Explain briefly how we detect how many processors there are,}
Explain that this method is good because it is (mostly) cross platform.

\plan{Explain why we want thread pinning.}
I wonder if there's any relevant literature.

\plan{Explain how we get thread pinning.}
This method is also (mostly) cross platform.

\plan{What about SMT, not all processors are equal.}
This does not matter when we are creating $P$ engines.
But it does matter when we create less than $P$ engines,
explain how bad CPU assignments are sub-optimal.

\plan{How do we handle SMT}
This uses a support library, which is cross platform, provided that it is installed.
We fall back to setcpuafinity() when it is not.

\paul{I am not going to talk about busy waiting since I have not written the
runtime system in a way that I can test or change this easily.}

\section{Idle loop}
\label{sec:idle_loop}
\status{Not written}

\plan{Describe the problem with the current algorithm.}
Engines wake up and periodically check for work by attempting to
steal work,
firstly, this means that there can be up to a 2ms (average 1ms) delay before
a spark is executed.
secondly, this checks for work too often, wasting resources.

\plan{Solution, wake engines for different types of work}
We modified the RTS so that waking an engine is easy, and it can be given a
message so that it knows where to look for work.

\plan{A lot of work went into preventing deadlocks due to race conditions,
a thread that is not yet sleeping if notified must wake up immediately.}

\plan{Extra benefit: when an engine is woken it can be told directly where
to find work, or be given the work directly.}

\plan{Extra benefit: we can be selective about which engine to wake,
while not implemented fully, we can wake a `nearby' engine so that
we can avoid communication between dies or sockets.}

\plan{Show the algorithm for the new idle loop.}
Note that we execute contexts before sparks,
this is more-likely to produce futures and it may reduce memory consumption.

\section{Proposed scheduling tweaks}
\label{sec:proposed_tweaks}
\status{Not written, May move to TS chapter}

I really think that this section will move to the \tscope chapter,
it will have more in common with that chapter and more data will be
available.
Secondly, \tscope can be used with micro-benchmarks to measure the
average costs of certain operations in the RTS.
I will not write it until at least the rest of this chapter is finished.

%\section{Proposed kernel support to manage processor resources}
%\label{sec:kernel_scheduling_help}
%
%\status{This may not be worth discussing until someone actually does it}
%
%Should I describe our proposal for OS kernel's to help
%applications with how many threads to use.
%GCD is related but does not fit into a language runtime system so
%easily~\cite{apple_gcd}.
%See also N:M threading.

%\section{Spare text}
%
%\status{This text will be moved up into one of the work stealing sections
%once those sections are ready}

%The spark is added to a global run queue of sparks, or if that queue is too
%full, because there's already enough parallelism,
%then the spark is added to a queue owned by the current context.
%\citet{wang_hons_thesis} intended to use the local queues for work stealing
%but had not completed his implementation,
%The work-stealing dequeue structure
%is described in \citet{Chase_2005_wsdeque}.
%see Chapter \ref{chap:rts} for details.
%
%and finds that spark is still at the head of its queue,
%it will pick it up and run it itself.
%This is a useful optimisation,
%% it is also really well-known.
%since it avoids using a separate context in the relatively common case
%that all the other CPUs are busy with their own work.
%This optimisation is also useful since it can avoid the creation of superfluous
%contexts and their stacks.
%

%When an engine becomes idle, it will first try
%to resume a suspended but runnable context if there is one.
%If not, it will attempt to run a spark from the global spark queue.
%If it successfully finds a spark, it will allocate a context,
%and start running the spark in that context.

% XXX: Mention global spark queue and spark sheduling above.
% XXX:

%Barrier code is placed at the end of each conjunct,
%this is named \code{join\_and\_continue} (Figure \ref{fig:par_conj}).
%This code starts by atomically decrementing the number of outstanding
%conjuncts in the conjunction's syncterm and checking the result for zero
%(the whole operation is thread-safe, not just the decrement).
%Algorithm \ref{alg:join_and_continue} shows the pseudo code for
%join\_and\_continue.


%XXX
%Parallel conjunctions are evaluated as described in Section
%\ref{sec:backgnd_merpar}.
%Sparks are added to the global spark queue if the global queue has room,
%otherwise they are pushed onto a context-local spark stack.
%Creating a lot of parallel work and using a single global work queue can be
%pesimistic,
%the queue itself can become a bottleneck:
%when many processors try to access it the same location in memory there will
%be many cache misses and delays.
%This is why \citet{wang_hons_thesis} choose to introduce local queues,
%and place work on them when there is a surplus of work on the global queue.
%
%When a engine finishes executing a context and reaches the barrier at the
%end of a parallel conjunct,
%it will check the context's local spark stack for any other work and attempt
%to execute it.
%Otherwise, it will either save the context to resume later or release the
%context before checking the global spark queue and global context queue.
%
%XXX Algorithm.
%
%Deciding too early, results.
%
