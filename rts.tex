
\status{This chapter is currently WIP}

Early in the project
we tested two manually parallelised programs:
a raytracer and a mandelbrot image generator.
Both of them have a single significant loop
whose iterations are independent of one-another.
We parallelised this loop in each program as it was the best place to
introduce parallelism,
but we did not get the speedups that we expected.
For these programs, automatic parallelisation cannot achieve
a greater speedup than we have achieved with manual parallelisation.
Therefore,
we chose to address the performance problems with manual parallelism
before we worked on automatic parallelism.

The chapter is structured as follows:
Section \ref{sec:gc} describes the garbage collector's effect on parallel
execution performance and how tuning some parameters of the garbage
collector can improve performance.
Section \ref{sec:old_scheduling} describes how the existing runtime
system schedules sparks.
It provides background material for Section
\ref{sec:old_scheduling_performance}
which benchmarks the runtime system and describes a significant problem with
spark scheduling.
We address those problems by introducing work stealing in Section
\ref{sec:work_stealing}.
This section is separated into two sub-sections
which describe the initial and revised versions of the work stealing
implementation.
Section \ref{sec:work_stealing} also includes benchmarks that show
how work stealing fixes the spark scheduling problem.
We made a number of improvements to the way that Mercury engines are created,
this includes thread pinning and support for SMT systems,
we describe these improvements in Section \ref{sec:thread_pinning}.
Finally, Section \ref{sec:idle_loop} describes our changes to how engines
idle,
and how and when they wake up to execute parallel work.

\section{Garbage collection tweaks}
\label{sec:gc}

\input{rts_gc}


\section{Original spark scheduling algorithm}
\label{sec:old_scheduling}

\status{This section is ready for review.}

\plan{Global spark queue and Contention wrt global queue}
Mercury has a global spark queue.
The runtime easily schedules a spark by placing it on the end of the
global queue.
An idle engine runs a spark by taking it from the beginning of the queue.
The global spark queue must be protected by a lock;
this prevents concurrent access from corrupting the queue.
The global spark queue and its lock can easily become a bottleneck when many
engines content for access to the global queue.

\plan{Local spark stack --- relieves contention on global queue}
\citet{wang-hons} anticipated this problem and created context local spark
stacks to avoid contention on the global queue.
Furthermore, the local spark stacks do not require locking.
When a parallel conjunction spawns off a spark; it places the spark either
at the end of the global spark queue or at the top of its local spark stack.
\plan{Spark scheduling decision.}
The runtime system appends the spark to the end of the global queue if:
an engine is idle, and
the number of contexts in use plus the number of sparks on the global queue
does not exceed the maximum number of contexts permitted.
Otherwise,
the runtime system pushes the spark onto the top of the context's local
spark stack.
% Note, if I ever change citations I need to fix 'Wang' here.
% XXX The next line can be searched for to find citations.
% \citet
Wang's scheduling decision has two aims:
First, to reduce the contention on the global queue,
especially in the common case that there is enough parallel work.
This also reduces the amount of locking.
Second, to reduce the amount of memory allocated
in contexts' stacks by reducing the number of contexts allocated.
Globally scheduled sparks may be converted into contexts,
so they are also included in this limit.
Note that sparks placed on the global queue are executed in a
first-in-first-out manner;
sparks placed on a context's local stack are executed in a
last-in-first-out manner.

\begin{algorithm}
\begin{algorithmic}
\Procedure{MR\_join\_and\_continue}{$ST, ContLabel$}
  \State acquire\_lock($ST.lock$)
  \State $ST.num\_outstanding \gets ST.num\_outstanding - 1$
  \If{$ST.num\_outstanding = 0$}
    \If{$ST.orig\_context = this\_context$}
      \State release\_lock($ST.lock$)
      \Goto{$ContLabel$}
    \Else
      \State schedule($ST.parent$)
      \State release\_lock($ST.lock$)
      \Goto{MR\_get\_global\_work}
    \EndIf
  \Else
    \State $spark \gets$ pop\_spark
    \If{$spark$}
      \If{$spark.ST.stack\_ptr = MR\_parent\_sp$}
%        \Comment{This spark belongs to the same parallel conjunction.
%        It can be executed immediatly.}
        \State release\_lock($ST.lock$)
        \Goto{$spark.code\_label$}
      \EndIf
      \State push\_spark($spark$)
    \EndIf
    \If{$ST.orig\_context = this\_context$}
       \State suspend($this\_context$)
       \State $this\_context \gets$ NULL
    \EndIf
    \State release\_lock($ST.lock$)
    \Goto{MR\_get\_global\_work}
  \EndIf
\EndProcedure
\end{algorithmic}
\caption{MR\_join\_and\_continue}
\label{alg:join_and_continue_peterw}
\end{algorithm}

\plan{barrier code, this is used to explain the right recursion problem.}
As an engine finishes executing a parallel conjunct,
it will execute the the barrier at the end of the conjunct.
The barrier is named \joinandcontinue and shown in
Algorithm \ref{alg:join_and_continue_peterw}.
If the parallel conjunction has been executed by
only one context,
then it is safe to use a version of the barrier code that does not use
locking,
this optimisation is not shown as it is equivalent and not relevant to
our discussion,
we mention it only for completeness.

The algorithm begins by checking if there are any outstanding conjuncts in
the parallel conjunction.
If there are no outstanding conjuncts and the current context is the parent
context,
then execution jumps to the label after the parallel conjunction.
If the current context is not the parent context then
the parent context is suspended (or about to be suspended).
We know this because there is no other parallel work to do for this
conjunction and the parent context may only work on this conjunction,
therefore it must be suspended.
The engine will schedule the parent context.
The current context's local work queue is guaranteed to be empty,
as this conjunction and any nested conjunctions are complete.
Therefore,
the engine will continue by jumping to the \getglobalwork routine
which is described below.
Alternatively,
if \joinandcontinue found that there are outstanding conjuncts then
the local spark stack is checked for a spark.
\paul{XXX: We compare parent\_sp, This works in all cases since the code
generator will ensure that parent\_sp is set to sp when a conjunction is
entered.}
A spark is used only if it was spawned off by the same parallel conjunction.
The only other spark that may exist, is one for a caller's parallel
conjunction.~\footnote{
    It is impossible to find a callee's spark on our local spark stack as
    all the parallel conjuncts in a callee must be complete before context
    would be allowed to continue from the barrier at the callee's parallel
    conjunction.}
This can only happen if this context is the original context for the
current parallel conjunction.
We cannot execute a spark for a caller's parallel conjunction because it may
depend on the execution of the current parallel conjunction.
Therefore, only sparks for the current parallel conjunction are executed.
If there was no suitable spark,
the algorithm checks if this context is the parent context.
If so, the algorithm suspends the context and
jumps to \getglobalwork.

\begin{algorithm}[htb]
\begin{algorithmic}
\Procedure{MR\_get\_global\_work}{}
  \State acquire\_lock($MR\_runqueue\_lock$)
  \Loop
    \If{$MR\_exit\_now$}
      \State release\_lock($MR\_runqueue\_lock$)
      \State MR\_destroy\_thread()
    \EndIf
    \State $ctxt \gets$ MR\_get\_runnable\_context()
    \If{$ctxt$}
      \State release\_lock($MR\_runqueue\_lock$)
      \If{$current\_context$}
        \State MR\_release\_context($current\_context$)
      \EndIf
      \State MR\_load\_context($ctxt$)
      \Goto $ctxt.resume$
    \EndIf
    \State $spark \gets$ MR\_pop\_spark($MR\_global\_spark\_queue$)
    \If{$spark$}
      \State release\_lock($MR\_runqueue\_lock$)
      \If{$\neg current\_context$}
        \State $ctxt \gets$ MR\_get\_free\_context()
        \If{$\neg ctxt$}
          \State $ctxt \gets$ MR\_create\_context()
        \EndIf
        \State MR\_load\_context($ctxt$)
      \EndIf
      \State $MR\_parent\_sp \gets spark.parent\_sp$
      \State $ctxt.thread\_local\_mutables \gets
        spark.thread\_local\_mutables$
      \Goto $spark.resume$
    \EndIf
    \State wait($MR\_runqueue\_cond, MR\_runqueue\_lock$)
  \EndLoop
\EndProcedure
\end{algorithmic}
\caption{\getglobalwork}
\label{alg:MR_get_global_work}
\end{algorithm}

\plan{Explain how work begins executing, for completeness.}
When an engine cannot get any local work it must search for global work.
Newly created engines, except for the first, also search for global work.
This is done by calling \getglobalwork.
\getglobalwork is shown in Algorithm \ref{alg:MR_get_global_work}.
Only one of the idle engines can execute \getglobalwork at a time.
This protects the context run queue and the global context queue from
concurrent access using the run queue's lock.
After acquiring the lock engines execute an infinite loop.
Each iteration first checks if the runtime system is being shut down,
if so,
then this thread releases the lock then destroys itself.
If the system is not being shut down,
the engine will search for a runnable context.
If it finds a context it releases the run queue lock, loads the context
and jumps to the resume point for the context.
If the engine already has a context that context is guaranteed to be unused;
therefore, it is released to the context free list.
If no context was found the engine attempts to take a spark from the global
spark queue.
If it finds a spark then it will need a context to execute the spark.
It will try to get a context from the free list, if there is none it will
create a new context.
Once it has a context it loads it
this copies the context's copies of registers into the engine such as the
stack pointer.
It loads the spark by initialising the engine's parent stack pointer
register and the spark's thread local mutables
(which are set by the context that created the spark)
into the context.
If the engine did not find any work it will wait using a condition
variable and the run queue lock.
The pthreads wait function is able to unlock the lock and wait on the
condition atomically, preventing race conditions. 
The condition variable is used to wake up the engine if either a spark is
placed on the global spark queue or a context is placed on the context run
queue.
When the engine wakes it will re-execute the infinite loop.

%An engine looks for global work first by checking the global context run queue.
%If it finds a runnable context and is still holding a context from a
%previous execution, it saves the old context onto the free context list.
%If there are no runnable contexts,
%it will take a spark from the global spark queue,
%and either use its current context to execute the spark,
%or allocate a new context (from the free context list if possible).
%If it is unsuccessful at finding work,
%it will go to sleep using a pthread condition variable and the global run
%queue's lock.
%This condition is used to wake engines when either contexts are added to the
%run queue,
%or sparks are added to the spark run queue.

\section{Prior spark scheduling performance}
\label{sec:old_scheduling_performance}

\status{Checking plan for this section.}

\begin{figure}
\begin{center}
\subfigure[Right recursive]{%
\label{fig:map_right_recursive}
\begin{tabular}{l}
\code{map(\_, [], []).} \\
\code{map(P, [X $|$ Xs], [Y $|$ Ys]) :-} \\
\code{~~~~P(X, Y) \&} \\
\code{~~~~map(P, Xs, Ys).} \\
\end{tabular}}
\subfigure[Left recursive]{%
\label{fig:map_left_recursive}
\begin{tabular}{l}
\code{map(\_, [], []).} \\
\code{map(P, [X $|$ Xs], [Y $|$ Ys]) :-} \\
\code{~~~~map(P, Xs, Ys) \&} \\
\code{~~~~P(X, Y).} \\
\end{tabular}}%
\end{center}
\caption{Right and left recursive map/3}
\label{fig:map_right_and_left_recursive}
\end{figure}

Section \ref{sec:gc} we ran our benchmarks with a recent version of the
runtime system.
In the rest of this chapter we describe many of the improvements to the
runtime system that improved parallel performance.

\plan{Introduce right recursion.}
Figure \ref{fig:map_right_and_left_recursive} shows two alternative, parallel
implementations of \code{map/3}.
While their declarative semantics are identical,
their operational semantics are very different.
In Section \ref{sec:backgnd_merpar} we explained that parallel conjunctions
are implemented by spawning off the second and later conjuncts and executing
the first conjunct directly.
In the right recursive case (Figure \ref{fig:map_right_recursive}),
the recursive call is spawned off as a spark,
and that in the left recursive case (Figure \ref{fig:map_left_recursive}),
the recursive call is executed directly, and the loops \emph{body} is
spawned off.
Programmers are taught about tail recursion,
and therefore they write right recursive code wherever possible.

\begin{table}
\paul{Make this easier to analyse by making the second column the actual
number of contexts, not contexts per engine.}
\begin{center}
\begin{tabular}{r|rr|rrrr}
\multicolumn{1}{c|}{Max no.} &
\multicolumn{2}{c|}{Sequmential} &
\multicolumn{4}{c}{Parallel w/ $N$ Engines} \\
\Cbr{of contexts} & \C{not TS} & \Cbr{TS} & \C{1}& \C{2}& \C{3}& \C{4}\\
\hline
2       & 23.2 (0.93) & 21.5 (1.00)
        & 21.5 (1.00) & 21.6 (1.00) & 21.6 (1.00) & 21.6 (1.00) \\
32  &-&-& 21.5 (1.00) & 21.6 (1.00) & 21.5 (1.00) & 21.2 (1.01) \\
64  &-&-& 21.5 (1.00) & 19.8 (1.09) & 18.5 (1.16) & 16.5 (1.30) \\
128 &-&-& 21.5 (1.00) & 13.2 (1.63) &  8.2 (2.62) &  6.1 (3.52) \\
256 &-&-& 21.5 (1.00) & 12.2 (1.76) &  8.1 (2.65) &  6.1 (3.52) \\
%\hline
%\multirow{5}{*}{Left} &
% 2      & 23.2       & 21.5     & 21.5 & 21.5 & 21.5 & 21.5 \\
%&32     & -          & -        & 21.5 & 21.5 & 21.5 & 21.5 \\
%&64     & -          & -        & 21.5 & 21.5 & 20.5 & 19.0 \\
%&128    & -          & -        & 21.5 & 18.5 & 15.8 & 12.9 \\
%&256    & -          & -        & 21.5 & 17.8 & 15.6 & 14.1 \\
\end{tabular}
\end{center}
\caption{Right recursion performance.}
\label{tab:right}
\end{table}

\plan{Show performance figures.}
Table \ref{tab:right} shows average elapsed time in seconds for the
mandelbrot\_lowalloc program over 20 samples.
We use the mandelbrot\_lowalloc program from Section \ref{sec:gc}.
Using this program we can easily observe the
speedup due to parallelism in Mercury without the effects of the garbage
collector.
The loop that iterates over the rows in the image uses right recursion.
It is similar to \code{map/3}
in Figure \ref{fig:map_right_recursive}.
\paul{XXX}
The left most column describes how many contexts may exist at once per
Mercury engine.
Values are omitted in the range 3--31 as they are not interesting:
their results are the same as those for 2 contexts per engine.
The next two columns give the elapsed execution time for a sequential
version of the program,
in this version of the program no parallel conjunctions where used.
The first of these, labelled ``not TS'',
is compiled without thread safety;
the second, labelled ``TS'',
is compiled with thread safety, meaning that it allows multiple engines to be
used: requiring each thread to use a register to point to its engine
structure (Section \ref{sec:backgnd_merpar}).
The ``TS'' version also compiles the garbage collector for thread safety.
The context limit is not used by the sequential versions of the programs,
hence some data items are not included.
The following four columns give the elapsed execution times
using one to four Mercury engines.
The numbers in parentheses are the ratio between the result and the 
sequential thread safe result.

\plan{Observations}
When using four engines and at least 128 contexts, the program
achieves a speedup of 3.52.
With fewer contexts, parallel speedups are limited.
Using independent parallelism there should be no need to suspend a context.
Therefore, the program should parallelise well enough when restricted to
a small (four to eight) number of contexts.

\plan{Describe the context limit problem.}
The cause of this problem is that right recursion uses a context for
each iteration of its loop, and then suspends that context:
Parallel conjunctions are evaluated as described in Section
\ref{sec:backgnd_merpar}.
The second and later conjuncts are spawned off while the first conjunct is
executed by the current context.
The barrier at the end of the first conjunct will block the context if
the other conjuncts have not yet completed.
This is likly as the recursive call almost always requires more
computation than a single iteration.
The context must either execute a spark due to the same parallel
conjunction or be blocked.
It cannot continue execution after the parallel conjunction as the code
after the conjunction often depends on values produced by the other
conjuncts in the conjunction.
Every spark placed on the global queue is converted into a new context
as no contexts have been released into the free list.
Each of these new contexts in turn executes the recursive call and then
becomes blocked within the same parallel conjunction.
The number of contexts quickly exceeds the context limit preventing
parallel execution.
Later in the project we developed a solution to this project which is
covered in Chapter \ref{chap:loop_control}.
In this chapter we investigate workarounds.

\plan{Suggest that left recursion might fix this,
(This is what we thought at the time).}
Only right recursion behaves in this way.
A left recursive predicate (Figure \ref{fig:left_recursion} has its
recursive call on the left of the parallel conjunction.
The context executing the conjunction sparks off the body of the loop,
in the figure this is \code{P},
and executes the recursive call directly.
In this case by the time the recursive call finishes \code{P}'s conjunct
should have also finished.
The context that created the parallel conjunction is less likely to be
blocked at the barrier,
and the context executing the spark is never blocked since it calls
\getglobalwork (it cannot have any local sparks).

\begin{table}
\begin{center}
\begin{tabular}{lr|rrrrrr}
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{Max no.\ of contexts} &
\multicolumn{2}{|c|}{Sequmential} &
\multicolumn{4}{|c}{Parallel w/ $N$ Engines} \\
\Cbr{} & & \C{not TS} & \Cbr{TS}  & \C{1}& \C{2}& \C{3}& \C{4}\\
\hline
\multirow{5}{*}{Include} &
 2       & 23.2       & 21.5      & 21.5 & 21.5 & 21.5 & 21.5 \\
&32      & -          & -         & 21.5 & 21.5 & 21.5 & 21.5 \\
&64      & -          & -         & 21.5 & 21.5 & 20.5 & 19.0 \\
&128     & -          & -         & 21.5 & 18.5 & 15.8 & 12.9 \\
&256     & -          & -         & 21.5 & 17.8 & 15.6 & 14.1 \\
\hline
Exclude &
-        & 23.3       & 21.5      & 21.7 & 17.9 & 15.6 & 14.2 \\
\end{tabular}
\end{center}
\caption{Left recursion with and without global sparks included in the context
limit}
\label{tab:2009_left_nolimit}
\end{table}

\plan{Show performance figures for left recursion.}
Table \ref{tab:2009_left_nolimit} shows benchmark results using left
recursion.
The left recursive figures are underwhelming, they are worse than right recursion.
\paul{I want to change the benchmarks before I do too much more work
on this section.}

\plan{Explain the premature scheduling problem that affects left-recursive programs.}

\plan{A second table of results shows that adjusting the context limit allows left-recursion to run faster.}
\paul{I would like to try yet-another experiment on left recursion where we remove this limit completely}

\plan{Reinforce that these results support the idea that scheduling decisions are made prematurely}

%\paul{consider diagram with stack}
%In the right recursive example,
%the recursive call is spawned off,
%the spark for the recursive call will be placed on the global spark queue.
%Another engine will wake up and take the spark from the global queue and
%convert it to a context.
%When it makes the recursive call it will execute the parallel conjunction
%inside and perform the same process.
%There is at most one spark on the global spark queue at any time.
%Each of these contexts,
%after creating the spark for their recursive call,
%will execute \code{P(X, Y)} and
%\joinandcontinue which blocks the context on the completion of
%its recursive call.
%This process continues:
%the runtime system will convert each spark into a context,
%and block each one at the barrier for the conjunction within its
%recursive call.
%This will quickly consume a lot of memory,
%most of which is used for the stacks within each context.
%
%Eventually the number of contexts in memory plus
%the number of sparks on the global queue is equal to the maximum number of
%contexts.
%At this point sparks are not added to the global queue but to their parent
%context's local stack.
%Contexts will not be created to execute these sparks.
%Therefore,
%this restricts the amount of memory allocated in contexts.
%Without this limit,
%a simple loop, such as in Figure \ref{fig:map_right_recursive},
%can easily consume all the physical memory in a system.
%This limit has the adverse effect of restricting how much parallelism
%in the program is exploited.
%This is why performance improves as we allow more contexts per engine.
%We will solve the memory usage problem and context limit in
%Chapter \ref{chap:loop_control}.
%
%In the left recursive program scheduling is quite different.
%The parallel conjunction creates a spark for \code{P(X, Y)} and executes the
%recursive call directly.
%The spark is converted into a context,
%that context does not execute another parallel conjunction since it does not
%execute the recursive call.
%Therefore, it will not become blocked on the \joinandcontinue barrier in any
%nested parallel conjunction.
%It will execute the barrier after \code{P(X, Y)},
%this however does not block this context.
%The context is not the conjunction's original context and therefore once it
%reaches this barrier it is free,
%if it has any sparks on its local queue it may execute them,
%otherwise the engine executing it will look for global work,
%either another context or a spark from the global queue.
%If there is a spark on the global queue the engine will use this context to
%execute it since the context is otherwise unused.
%
%This led us to believe that the left recursion would be more efficient than
%right recursion,
%namely that since contexts are reused, the number of contexts wouldn't climb
%and prevent parallelism from being exploited.
%As Table \ref{tab:right_v_left} shows, we were wrong:
%the context limit is affecting performance.
%As discussed, a left-recursive loop spawns of calls to \code{P} as sparks
%and executes its recursive call directly.
%It will, very quickly,
%make many recursive calls, spawn off many sparks.
%The context limit includes sparks on the global queue since
%executing them can require the creation of new contexts,
%Furthermore, if they were not included and the runtime system refused to
%convert a spark on the global queue into a context the system could become
%deadlocked.
%In the left recursive case,
%the context limit will be reached very quickly,
%often before engines have begun taking sparks from the queue and executing
%them.
%Once the limit is reached sparks are placed on the contexts local queues
%where they cannot be executed in parallel.
%The smaller the context limit,
%the more quickly the limit is reached and the fewer contexts are placed on
%the global queue.
%Additionally,
%the loop placing sparks on its context's local stack will execute very
%quickly.
%
%We concluded that
%in the left recursive case
%the scheduling decision for each spark is made much earlier than the spark's
%execution.
%Specifically,
%when the decision to place the spark on the global queue or local stack is
%made,
%often the context limit has already been reached:
%\paul{Need to decide how I communicate who the actor is for scheduling
%decisions.}
%the context will place the spark on its local stack.
%Later, when a different engine becomes idle,
%it cannot access the spark since it is on another engine's context's spark
%stack.
%At this point it is apparent that the scheduling decision made when the
%spark was placed on the local stack was incorrect,
%as there is an idle engine ready to execute the spark,
%and because contexts are re-used (in left recursion) there is either a free
%context or we can easily create one.


\plan{Avoid the right-recursion problem by reordering independent conjunctions.}


\section{Work stealing implementation}
\label{sec:work_stealing}

The stack data structure used is described by \citet{workstealing_queue},
this was chosen as it could support work stealing (Section
\ref{sec:work_stealing}).
%The top of the stack is sometimes referred to as the \emph{hot end},
%since it is used frequently.
%Likewise, the bottom of the stack is sometimes called the
%\emph{cold end}, since it is only used to implement work stealing.
%The top of the stack, or hot end, can be used without locking or atomic
%operations.
%This is desirable, since it makes common operations inexpensive.
%The local context uses the top of the stack only,
%therefore sparks placed on this stack are scheduled in a
%last-in-first-out manner.

\status{Not written}

\plan{Acknowledge work stealing used elsewhere in other runtime systems.}

\subsection{Initial work stealing implementation}

\plan{I believe that Peter discussed work stealing briefly in his thesis,
I should check this and see what he said.}

\plan{Say that stacks queues are associated with contexts.}

\plan{Describe the data structure used to implement these stacks and its properties.}
Local context can use the hot end without synchronisation.
Other contexts can use the cold end with a CAS,
Memory barriers are used to ensure writes appear in the correct order.

\plan{Describe how work stealing policies work}
What happens to the global queue,
in what cases is work stolen,
Show algorithms for work stealing attempts.
Describe work stealing timeout.

\plan{Benchmark}

This subsection was joint work with Peter Wang.

\subsection{Final work stealing implementation}

\plan{Describe problems with associating stacks with contexts}
The number of stacks varies,
Stealing uses a global lock to determine which stack to steal from.

\plan{Prove that even though there are N engines and M contexts and M may be
larger than N, that there will be at most N of the M contexts with work on
their queues}
Therefore:
Stealing is unnecessary complicated.
In pathological cases many attempts can be made without success,
a thief may give up even though there is parallelism.

\plan{We associate stacks with engines}
This removes the above problems how.

\plan{Show stealing algorithm there are any,}
Find out if I started tracking stealing per engine or not.

\plan{Show how this is safe.}
When a parallel conjunction's barrier is executed and a conjunct is
outstanding, if its spark is on this engine's stack it must be at the top of
the stack.
This invariant should be kept because the context can be re-used if
'compatible' work is found at the top of the spark stack.
This invariant is soft.

\plan{Benchmark}

\section{Thread pinning}
\label{sec:thread_pinning}
\status{Not written}

\plan{Explain why we want $P$ engines when there are $P$ processors}

\plan{Explain briefly how we detect how many processors there are,}
Explain that this method is good because it is (mostly) cross platform.

\plan{Explain why we want thread pinning.}
I wonder if there's any relevant literature.

\plan{Explain how we get thread pinning.}
This method is also (mostly) cross platform.

\plan{What about SMT, not all processors are equal.}
This does not matter when we are creating $P$ engines.
But it does matter when we create less than $P$ engines,
explain how bad CPU assignments are sub-optimal.

\plan{How do we handle SMT}
This uses a support library, which is cross platform, provided that it is installed.
We fall back to setcpuafinity() when it is not.

\paul{I am not going to talk about busy waiting since I have not written the
runtime system in a way that I can test or change this easily.}

\section{Idle loop}
\label{sec:idle_loop}
\status{Not written}

\plan{Describe the problem with the current algorithm.}
Engines wake up and periodically check for work by attempting to
steal work,
firstly, this means that there can be up to a 2ms (average 1ms) delay before
a spark is executed.
secondly, this checks for work too often, wasting resources.

\plan{Solution, wake engines for different types of work}
We modified the RTS so that waking an engine is easy, and it can be given a
message so that it knows where to look for work.

\plan{A lot of work went into preventing deadlocks due to race conditions,
a thread that is not yet sleeping if notified must wake up immediately.}

\plan{Extra benefit: when an engine is woken it can be told directly where
to find work, or be given the work directly.}

\plan{Extra benefit: we can be selective about which engine to wake,
while not implemented fully, we can wake a `nearby' engine so that
we can avoid communication between dies or sockets.}

\plan{Show the algorithm for the new idle loop.}
Note that we execute contexts before sparks,
this is more-likely to produce futures and it may reduce memory consumption.

\section{Proposed scheduling tweaks}
\label{sec:proposed_tweaks}
\status{Not written, May move to TS chapter}

I really think that this section will move to the \tscope chapter,
it will have more in common with that chapter and more data will be
available.
Secondly, threadscope can be used with micro-benchmarks to measure the
average costs of certain operations in the RTS.
I will not write it until at least the rest of this chapter is finished.

%\section{Proposed kernel support to manage processor resources}
%\label{sec:kernel_scheduling_help}
%
%\status{This may not be worth discussing until someone actually does it}
%
%Should I describe our proposal for OS kernel's to help
%applications with how many threads to use.
%GCD is related but does not fit into a language runtime system so
%easily~\cite{apple_gcd}.
%See also N:M threading.

%\section{Spare text}
%
%\status{This text will be moved up into one of the work stealing sections
%once those sections are ready}

%The spark is added to a global run queue of sparks, or if that queue is too
%full, because there's already enough parallelism,
%then the spark is added to a queue owned by the current context.
%\citet{wang_hons_thesis} intended to use the local queues for work stealing
%but had not completed his implementation,
%The work-stealing dequeue structure
%is described in \citet{Chase_2005_wsdeque}.
%see Chapter \ref{chap:rts} for details.
%
%and finds that spark is still at the head of its queue,
%it will pick it up and run it itself.
%This is a useful optimisation,
%% it is also really well-known.
%since it avoids using a separate context in the relatively common case
%that all the other CPUs are busy with their own work.
%This optimisation is also useful since it can avoid the creation of superfluous
%contexts and their stacks.
%

%When an engine becomes idle, it will first try
%to resume a suspended but runnable context if there is one.
%If not, it will attempt to run a spark from the global spark queue.
%If it successfully finds a spark, it will allocate a context,
%and start running the spark in that context.

% XXX: Mention global spark queue and spark sheduling above.
% XXX:

%Barrier code is placed at the end of each conjunct,
%this is named \code{join\_and\_continue} (Figure \ref{fig:par_conj}).
%This code starts by atomically decrementing the number of outstanding
%conjuncts in the conjunction's syncterm and checking the result for zero
%(the whole operation is thread-safe, not just the decrement).
%Algorithm \ref{alg:join_and_continue} shows the pseudo code for
%join\_and\_continue.


%XXX
%Parallel conjunctions are evaluated as described in Section
%\ref{sec:backgnd_merpar}.
%Sparks are added to the global spark queue if the global queue has room,
%otherwise they are pushed onto a context-local spark stack.
%Creating a lot of parallel work and using a single global work queue can be
%pesimistic,
%the queue itself can become a bottleneck:
%when many processors try to access it the same location in memory there will
%be many cache misses and delays.
%This is why \citet{wang_hons_thesis} choose to introduce local queues,
%and place work on them when there is a surplus of work on the global queue.
%
%When a engine finishes executing a context and reaches the barrier at the
%end of a parallel conjunct,
%it will check the context's local spark stack for any other work and attempt
%to execute it.
%Otherwise, it will either save the context to resume later or release the
%context before checking the global spark queue and global context queue.
%
%XXX Algorithm.
%
%Deciding too early, results.
%
