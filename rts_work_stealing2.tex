
\status{Not written}

In this section we take the opportunity to improve on our work stealing
implementation from Section \ref{sec:rts_work_stealing}.
While we made these improvments we also found it useful to change how idle
engines behave.
Although these too changes are conceptually distinct,
they where made together and their implementations are interlinked.
Therefore we will present and benchmark them together as one set of changes.

\plan{Describe problems with associating stacks with contexts}
Sparks are stored on context local deques,
this has a several significant problems.

\begin{description}

    \item[There is a dynanic number of spark deques]~

    The number of contexts changes during a programs execution,
    therefore the number of spark deques also changes.
    This means that we must have code to manage this chaging number of
    deques.
    This code makes the runtime system more complicated necessary,
    both when stealing a spark and when destroying or creating a context.

    \item[This requires locking]~

    The management of contexts must be thread safe so that the set of
    spark deques is not currupted.
    We store spark deques in a global array protected by a lock.
    It may be possible to replace the array with a lock free datastructure.
    However it is better to remove the need of thread safty by using a
    constant set of deques.

    \item[A large number of contexts makes work stealing slower]~
    
    In previous sections
    we have shown that the number of contexts in use can often be very high,
    much higher than the number of Mercury engines.
    If there are $N$ engines and $M$ contexts,
    then there can be at most $N$ contexts running and
    at least $M-N$ contexts suspended (blocked and waiting to run),
    In some cases there can be at most $M-1$ suspended contexts.
    A context can become suspended in one of two ways:
    by blocking on a future's value in call to \wait,
    or by blocking on an incomplete conjunct in a call to \joinandcontinue.
    We attempt to minimise the former case and the later case cannot occur
    if the context has a spark on its local spark deque (it would run the
    spark rather than block).
    Therefore the large majority of the suspended contexts will not have
    sparks on their deques,
    and the probability of selecting a deque at random with a spark on its
    stack is only a little bit higher than $M \choose N$ at best and
    and $M \choose 1$ at worst.
    Furthermore the value of $M$ can be very high in pathological cases.
    If an engine does not successfully steal a spark from a deque,
    it will continue by trying to steal a spark from a different deque.
    An engine can exhaust all its attempts, even when there is work
    available.
    Upon exhausting all its attempts or all the deques,
    the engine will sleep before making another round of attempts.
    Each round of attempts (regardless of success or failure) has a
    complexity of $O(M)$.

\end{description}

\noindent
\plan{We associate stacks with engines}
The solution to all of these problems is to associate spark deques with
engines rather than with contexts.
A running Mercury program has a constant number of engines,
and therefore the number of spark deques will not vary.
This means that we can remove the code used to resize the deque array when a
context is created or destroyed, simplfying the system and making these
procedures faster.
We can also remove the locking code in \trystealspark used to ensure that
the array is not changed while a thief is trying to steal a spark.
The cost of work stealing also becomes linear in the number of engines
rather than the number of contexts (there are usually fewer engines than
contexts).

\plan{Show how this is safe.}
Associating the spark deques with engines can change the order in which
sparks are executed.
A context that is suspended by a call to \wait may contain sparks,
when engines contain spark deques those sparks can be executed by the engine
that was running the context.
This does not affect the program's safety,
the program will not become deadlocked provided that
each\footnote{
    Sometimes a specific engine must execute a specific context so that the
    context's computation can access something on the C stack.
    Therefore all engines must check the context run queue for such a
    context.
    This is an implementation detail of foreign C code.
    }
of the engines checks the context run queue for a context
to execute.
This happens each time an engine calls \getglobalwork.
We believe that it is preferable to run an idle context rather than a new
spark,
a context represents work that was scheduled earlier and therefore may
make more parallel work available,
either by creating spark(s) or signalling future(s).
Signaling a future as early as possible can,
in some cases,
prevent a call to \wait from blocking some other context.

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{MR\_try\_steal\_spark}{$spark\_ptr$}
  \State $result \gets false$
  \For{$attempt = 0$ to $MR\_num\_engines$}
    \State $victim\_index \gets
        (MR\_engine.victim\_counter + attempt) \bmod MR\_num\_engines$
    \State $deque \gets
       MR\_spark\_deques$[$victim\_index$]
    \State $result \gets$ steal\_spark($deque$, $spark\_ptr$)
    \If{$result$}
      \State break
    \EndIf
  \EndFor
  \State $MR\_engine.victim\_counter \gets
    MR\_engine.victim\_counter + offset$
  \State \Return $result$
\EndProcedure
\end{algorithmic}
\caption{MR\_try\_steal\_spark}
\label{alg:try_steal_spark_initial}
\end{algorithm}

\plan{Show new \trystealspark}
Find out if I started tracking stealing per engine or not.

\plan{Describe the problem with the current algorithm.}
Engines wake up and periodically check for work by attempting to
steal work,
firstly, this means that there can be up to a 2ms (average 1ms) delay before
a spark is executed.
secondly, this checks for work too often, wasting resources.

\plan{Solution, wake engines for different types of work}
We modified the RTS so that waking an engine is easy, and it can be given a
message so that it knows where to look for work.

\plan{A lot of work went into preventing deadlocks due to race conditions,
a thread that is not yet sleeping if notified must wake up immediately.}

\plan{Show new \getglobalwork}
\plan{Show the algorithm for the new idle loop.}
Note that we execute contexts before sparks,
this is more-likely to produce futures and it may reduce memory consumption.

\plan{Extra benefit: when an engine is woken it can be told directly where
to find work, or be given the work directly.}

\plan{Extra benefit: we can be selective about which engine to wake,
while not implemented fully, we can wake a `nearby' engine so that
we can avoid communication between dies or sockets.}

\input{tab_work_stealing_revised}

\plan{Benchmark}

\plan{Evaluation}

\plan{Further potential work}

