
\status{This section's content is complete}

% This is a figure since there are a number of references to it.
\begin{figure}
\begin{verbatim}
map_foldl(M, F, L, Acc0, Acc) :-
    (
        L = [],
        Acc = Acc0
    ;
        L = [H | T],
        (
            M(H, MappedH),
            F(MappedH, Acc0, Acc1)
        &
            map_foldl(M, F, T, Acc1, Acc)
        )
    ).
\end{verbatim}
%\vspace{2mm}
\caption{Parallel \mapfoldl{}}
\label{fig:mapfoldl}
%\vspace{-1\baselineskip}
\end{figure}

\begin{figure}
\begin{verbatim}
XXX: Maybe make the int an enum?
struct MR_Future {
    /* lock preventing concurrent accesses */
    MercuryLock     MR_fut_lock;
    /* whether this future has been signalled yet */
    int             MR_fut_signalled;

    /* linked list of all the contexts blocked on this future */
    MR_Context      *MR_fut_suspended;
    MR_Word         MR_fut_value;
};
\end{verbatim}
\caption{Future data structure}
\label{fig:future}
\end{figure}

Mercury's mode system allows a conjunct in a sequential conjunction to consume
variables that are produced by conjuncts to its left, but not to its right.
However, Mercury supported only independent parallelism,
where no communication was allowed between conjunctions.
\citet{wang_dep_par_conj,wang_hons_thesis} relaxed this;
now parallel conjunctions have the same mode constraints as sequential
conjunctions.
Parallel conjunctions such as the one in Figure \ref{fig:mapfoldl} may now
communicate through \emph{shared variables} such as \code{Acc1}.
A shared variable is a variable that is bound sometime within the parallel
conjunction and occurs in more than one conjunct.
Recall that in Mercury the code location where a variable become bound is known
at compile time;
therefore,
shared variables are identified at compile time.
The compiler replaces each shared variable with a \emph{future} \citep{multilisp},
which is used to safely communicate the variable's value between conjuncts.

Figure \ref{fig:future} shows the future data structure,
which contains room for the value of the variable,
a flag indicating whether the variable has been produced yet,
a queue of consumer contexts waiting for the value, and a mutex.
The initial value of the future has the flag set to `not yet produced'.

Consumers call \wait when they want to retrieve a value from the future,
this acquires the lock, and if \code{MR\_fut\_signalled} is true, retrieves
\code{MR\_fut\_value} before releasing the lock.
If \code{MR\_fut\_signalled} was false, then the current context is added to
the list of suspended contexts before unlocking the future.
The engine will then suspend the context and look for other work.
Once the value of the future is provided,
the context will be woken up along with the others on the list of suspended contexts.
\wait contains an optimisation; it will check \code{MR\_fut\_signalled} before
acquiring the lock as well as after.
If it is true before the lock is acquired then it can safely retrieve the
future's value without using the lock.

A producer will call \signal to place a value into a future and wake up any
suspended contexts.
\signal will also acquire the lock to ensure that it does not race with any \wait.
The value of the future is written to memory,
before 
\code{MR\_fut\_signalled} is set to true.
These operations are separated by a memory barrier to ensure that they are
visible to other threads in this order.
After releasing the lock, \signal will schedule the suspended contexts.
Because \signal has no outputs and is deterministic,
it must be declared as impure so that the compiler will not optimise away calls
to it.

\get is provided as an alternative to \wait,
however, it may only be used if the future's value is guaranteed to be
available, which can happen if the same execution path has already called
either \signal or \wait.
It is therefore necessary that \wait is never optimised away, even if its
output is not used by other code;
\wait is therefore declared as impure.

To minimise waiting,
the compiler pushes signal operations on each future
as far to the left into the producer conjunct as possible,
and it pushes wait operations
as far to the right into each of its consumer conjuncts as possible.
This means not only pushing them
into the body of the predicate called by the conjunct,
but also into the bodies of the predicates they call,
with the intention being that
each signal is put immediately after
the primitive goal that produces the value of the variable,
and each wait is put immediately before
the leftmost primitive goal that consumes the value of the variable.
Since the compiler has complete information
about which goals produce and consume which variables,
the only things that can stop the pushing process from placing the
wait immediately before the value is to be used and the signal
immediately after it is produced are
higher order calls and module boundaries:
the compiler cannot push a wait or signal operation
into the body of a predicate
if it does not have access to the identity or to the body of the predicate.


\begin{figure}
\begin{verbatim}
map_foldl(M, F, L, Acc0, Acc) :-
    (
        L = [],
        Acc = Acc0
    ;
        L = [H | T],
        new_future(FutureAcc1),
        (
            M(H, MappedH),
            F(MappedH, Acc0, Acc1),
            signal_future(FutureAcc1, Acc1)
        &
            map_foldl_par(M, F, T, FutureAcc1, Acc)
        )
    ).

map_foldl_par(M, F, L, FutureAcc0, Acc) :-
    (
        L = [],
        wait_future(FutureAcc0, Acc0),
        Acc = Acc0
    ;
        L = [H | T],
        new_future(FutureAcc1),
        (
            M(H, MappedH),
            wait_future(FutureAcc0, Acc0),
            F(MappedH, Acc0, Acc1),
            signal_future(FutureAcc1, Acc1)
        &
            map_foldl_par(M, F, T, FutureAcc1, Acc)
        )
    ).
\end{verbatim}
%\vspace{2mm}
\caption{\mapfoldl{} with synchronisation}
\label{fig:map_foldl_sync}
%\vspace{-1\baselineskip}
\end{figure}

Given the \mapfoldl predicate in Figure~\ref{fig:mapfoldl},
this synchronisation transformation
generates the code in Figure~\ref{fig:map_foldl_sync}.


